# 问题 05：事件监听清理不完整

## 1. 问题描述

部分事件监听在成功路径未明确解绑，连接频繁建立/中断场景下可能累积监听器，带来资源泄漏和重复回调风险。

## 2. 问题代码位置

- `src/monitor.ts:878`~`890`：`sleepWithAbort()` 内 `abort` 监听未在 resolve 后清理
- `src/monitor.ts:1029`~`1038`：`connectOnce()` 注册 `abort` 监听
- `src/monitor.ts:1041`~`1048`：`connect()` 成功路径未移除上面的 `abort` 监听（仅失败路径在 `:1050` 有 remove）

## 3. 可能影响

- 长期运行时监听器累积，内存占用增加。
- 某些阶段可能出现重复触发、状态竞争。
- 连接抖动场景下，问题更隐蔽且难复现。

## 4. 修复方案

### 方案 A（推荐）：统一 finally 清理

1. 为 `connectOnce()` 引入统一 `cleanupListeners()`。
2. 在成功、失败、abort 三条路径都执行清理。
3. `sleepWithAbort()` 在 `resolve/reject` 前都解绑 `onAbort`。

### 方案 B：事件工具封装

- 封装 `onceWithCleanup(signal, handler)` 工具，避免每处重复写解绑逻辑。

## 5. 验证建议

- 压测场景：模拟高频重连 1000 次，确认监听器数量稳定。
- 加入内存快照或监听器计数日志，观察是否持续增长。
- 单测验证成功路径也执行 `removeEventListener`。

