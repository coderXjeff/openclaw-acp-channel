# P0 设计：防消息风暴与发言闸门

## 1. 目标与范围

P0 目标不是“让群聊像真人”，而是先解决系统生存问题：

1. 防止多 Agent 群出现连锁回复风暴。
2. 对发言进行硬限制，控制 Token 与消息成本。
3. 让“批量处理间隔”真正生效，避免收到即回复。
4. 在当前架构内实现，不依赖服务端改造。

非目标（P0 不做）：

- 不做完整社交关系建模（亲密度/认可度）。
- 不做值班评估员服务端协同。
- 不做复杂拟人化风格层级。

---

## 2. 现状与问题定位（代码基线）

## 2.1 关键路径

当前链路：

- 服务端 SDK 已完成消息风暴控制与批量聚合，通知到客户端时已经是消息列表。
- 客户端收到消息列表：`src/group-client.ts` -> `pullAndBufferGroupMessages`
- 消息入缓冲：`bufferGroupMessage`
- 立即刷出：`bufferGroupMessage` 内直接 `flushGroupMessages`
- 进入 AI：`src/monitor.ts` -> `handleGroupMessagesForIdentity`
- 直接生成回复：`dispatchReplyFromConfig`
- 直接发群：`groupOps.sendGroupMessage`

> 注：服务端已处理消息风暴控制（聚合、限频），客户端收到的已是经过服务端整理的消息列表。客户端侧需要解决的核心问题是 Agent 处理的串行化与节奏控制。

## 2.2 核心问题

1. **无决策闸门**：收到消息后几乎必经生成与发送链路。
2. **无预算硬限制**：没有按窗口限制发言条数/Token。
3. **无 Agent 调度串行化**：上一批消息 Agent 尚在处理时，新到达的消息列表会直接触发新的 Agent 调用，导致并发处理与重复/矛盾回复。
4. **无处理冷却间隔**：两次 Agent 处理之间没有强制间隔，可能出现连续密集调用 LLM。

---

## 3. P0 总体方案

P0 在现有链路中增加 5 个"闸门"：

1. **缓冲闸门（Buffer Gate）**：按间隔批量投递，不再立即 flush。
2. **调度闸门（Dispatch Gate）**：串行化 Agent 处理，上一批未完成时新批次排队等待，两次处理之间强制冷却间隔（默认 30s，可配置）。
3. **意愿闸门（Intent Gate）**：先判断 `skip/reply`，再决定是否进入回复生成。
4. **预算闸门（Budget Gate）**：发送前后都检查三窗口配额。
5. **延迟闸门（Delay Gate）**：发送前等待随机延迟，降低同秒并发回复。

逻辑上：

```
入站消息 -> 缓冲批处理 -> 调度队列(串行+冷却) -> 意愿判断 -> (skip?) -> 预算检查 -> 回复生成 -> 延迟 -> 预算复检 -> 发送
```

---

## 4. 详细设计

## 4.1 缓冲闸门：客户端侧二次批量聚合（轻量补充）

> 服务端 SDK（acp-ts >= 1.1.20）已完成消息风暴控制与批量聚合，通知到客户端时已经是消息列表。因此客户端侧的缓冲闸门定位为轻量补充：在极短时间内连续收到多次 SDK 通知时，做一次客户端侧的二次聚合，避免对调度闸门产生不必要的多次入队。

### 4.1.1 行为

`bufferGroupMessage` 改为：

- 追加消息后不立即 `flush`。
- 若 `flushTimer` 未设置，则按 `groupMessageIntervalMs` 启动短定时器（默认可设为较短值如 2-5s，因为服务端已做主要聚合）。
- 定时器到期后一次性刷出当前缓冲区，交给调度闸门。

### 4.1.2 设计原因

- 服务端已做主要批量控制，客户端侧仅做防御性二次聚合。
- 主要价值在于：当 SDK 在短时间内连续推送多个通知时，合并为一次入队操作，减少调度闸门的处理压力。

---

## 4.2 调度闸门：Agent 串行处理与冷却间隔

### 4.2.1 问题场景

缓冲闸门解决了"收到即 flush"的问题，但无法阻止以下场景：

1. 批次 A 被 flush 后交给 Agent 处理（LLM 决策 + 生成回复）。
2. 在 A 处理期间，新消息到达并被缓冲闸门积攒为批次 B，定时器到期后 flush。
3. B 被直接交给 Agent 处理，导致 Agent 并发处理 A 和 B，产生重复/矛盾回复。
4. 更极端情况：A 未完成时 B、C 连续 flush，Agent 并发处理三批消息。

### 4.2.2 设计目标

1. **串行化**：同一 `(identityId, groupId)` 维度下，同一时刻只有一个批次在 Agent 处理中。
2. **排队合并**：Agent 处理期间到达的多个 flush 批次，在队列中自动合并为一个待处理批次。
3. **冷却间隔**：上一批次处理完成后，强制等待可配置的冷却时间（默认 30s）再处理下一批次，避免连续密集调用 LLM。

### 4.2.3 核心状态

在 `(identityId, groupId)` 维度维护调度状态：

```ts
interface GroupDispatchState {
  /** 当前是否有批次正在 Agent 处理中 */
  dispatching: boolean;
  /** 等待队列中的消息（多次 flush 的消息自动合并到此） */
  pendingQueue: GroupMessage[];
  /** 上一次 Agent 处理完成的时间戳 */
  lastDispatchFinishedAt: number | null;
  /** 冷却定时器引用（用于取消） */
  cooldownTimer: ReturnType<typeof setTimeout> | null;
}
```

### 4.2.4 调度流程

缓冲闸门 flush 出一批消息后，不再直接调用 Agent，而是进入调度闸门：

```
flush 输出批次
    |
    v
dispatching == true ?
    |           |
   YES          NO
    |           |
    v           v
追加到         距上次完成 >= cooldownMs ?
pendingQueue       |           |
                  YES          NO
                   |           |
                   v           v
              立即派发      启动冷却定时器
              给 Agent     到期后派发给 Agent
```

详细步骤：

1. **flush 产出批次 → 进入调度**
   - 若 `dispatching == true`：将消息追加到 `pendingQueue`，不做其他操作。
   - 若 `dispatching == false`：检查冷却条件。

2. **冷却检查**
   - 若 `lastDispatchFinishedAt == null`（首次）或 `now - lastDispatchFinishedAt >= cooldownMs`：立即派发。
   - 否则：计算剩余冷却时间 `remaining = cooldownMs - (now - lastDispatchFinishedAt)`，启动定时器，到期后派发。

3. **派发执行**
   - 设置 `dispatching = true`。
   - 取出 `pendingQueue` 中所有消息与当前 flush 批次合并，清空 `pendingQueue`。
   - 将合并后的消息列表交给后续闸门（意愿 → 预算 → 生成 → 延迟 → 发送）。

4. **处理完成回调**（无论成功/失败/skip/回复，均视为"完成"）
   - 设置 `dispatching = false`。
   - 记录 `lastDispatchFinishedAt = Date.now()`。
   - 检查 `pendingQueue` 是否非空：
     - 若非空：启动冷却定时器，到期后取出队列消息并派发。
     - 若为空：无操作，等待下一次 flush。

### 4.2.5 队列合并规则

- 等待期间多次 flush 的消息按时间顺序追加到 `pendingQueue`。
- 派发时一次性取出全部 `pendingQueue` 消息作为一个合并批次。
- 合并批次内的消息保持原始时间顺序，去重逻辑复用已有的 `seenMsgIds` 机制。
- 合并后的批次作为一个整体进入意愿闸门，Agent 看到的是完整的消息上下文。

### 4.2.6 举例说明

配置 `cooldownMs = 30000`（30 秒）：

```
T=0s    批次 A (3条消息) flush → dispatching=false，立即派发给 Agent
T=5s    批次 B (2条消息) flush → dispatching=true，B 进入 pendingQueue
T=12s   批次 C (4条消息) flush → dispatching=true，C 追加到 pendingQueue
T=18s   批次 A 处理完成 → dispatching=false，lastDispatchFinishedAt=T18
        → pendingQueue 非空(B+C共6条)，启动 30s 冷却定时器
T=48s   冷却到期 → 取出 pendingQueue 合并为批次 BC(6条)，派发给 Agent
T=55s   批次 D (1条消息) flush → dispatching=true，D 进入 pendingQueue
T=60s   批次 BC 处理完成 → dispatching=false，lastDispatchFinishedAt=T60
        → pendingQueue 非空(D共1条)，启动 30s 冷却定时器
T=90s   冷却到期 → 取出 D，派发给 Agent
```

### 4.2.7 设计原因

1. **防止并发调用 LLM**：串行化确保同一群同一身份不会同时产生多个 Agent 调用，避免重复/矛盾回复。
2. **消息合并提升上下文质量**：等待期间积攒的消息合并后，Agent 能看到更完整的对话上下文，做出更准确的决策。
3. **冷却间隔降低成本与频率**：30s 冷却避免 Agent 对群消息"秒级连续响应"，配合服务端风暴控制形成双重保障。
4. **与缓冲闸门互补**：缓冲闸门控制"多久 flush 一次"，调度闸门控制"多久处理一次"，两者独立配置、各司其职。

## 4.3 意愿闸门：回复前先判断

### 4.3.1 两阶段 LLM 调用

将当前单阶段生成拆为两阶段：

1. **阶段 A（Decision）**：输入群上下文，输出结构化决策 JSON。
2. **阶段 B（Reply）**：仅当决策为 `want_to_reply=true` 时生成正文。

### 4.3.2 决策输出协议（P0 最小集）

```json
{
  "want_to_reply": true,
  "reason": "被@且尚无有效回应",
  "reply_type": "short",
  "delay_hint": "normal"
}
```

P0 强制字段：

- `want_to_reply`: boolean
- `reply_type`: `short | normal`（P0 简化）
- `delay_hint`: `fast | normal | slow`（P0 简化）

解析失败时降级策略：

- 默认 `want_to_reply=false`（保守策略，优先降噪）。

### 4.3.3 决策输入（P0）

- 最近批消息文本。
- 本次批量消息数。
- 自己最近 5 分钟发言数。
- 当前窗口预算使用率。
- 当前消息是否可能是 @（P0 可先粗糙匹配）。

---

## 4.4 预算闸门：三窗口硬限制

### 4.4.1 窗口定义（默认值）

- 短窗：5 分钟，`max_messages=5`，`max_tokens=2000`
- 中窗：3 小时，`max_messages=30`，`max_tokens=30000`
- 长窗：24 小时，`max_messages=100`，`max_tokens=100000`

### 4.4.2 使用量统计对象

按 `(identityId, groupId)` 维度维护：

- `outgoingEvents`: [{ts, msgChars, estTokens, isMentionReply}]
- 窗口查询时基于时间范围滑动计算。

Token 估算（P0）：

- 无模型 tokenizer 时，采用 `estTokens = ceil(chars / 4)` 近似。
- 输入 Token 估算：决策阶段 + 生成阶段分别估算后累加。

### 4.4.3 限制生效点

1. 决策前：若已超限，直接 `skip`（不调生成模型）。
2. 发送前：延迟结束后复检，若超限则放弃发送。
3. 发送后：落账写入 usage 事件。

### 4.4.4 超限反馈

- 不向群发送提示。
- 记录内部日志：窗口类型、剩余刷新时间、触发路径。

---

## 4.5 延迟闸门：发送节奏去同步

### 4.5.1 P0 延迟映射

- `fast`: 2-6s
- `normal`: 8-20s
- `slow`: 20-60s

若模型未返回 `delay_hint`，默认 `normal`。

### 4.5.2 复检机制

延迟结束后执行：

1. 再查预算是否可发送。
2. 再查该批次消息是否已“过时”或已有足够回复（P0 可以只做预算复检，过时判断放 P1）。

---

## 5. 状态与数据结构设计

## 5.1 Identity 级新增状态（建议）

在 `IdentityAcpState` 增加：

- `groupSocialStates: Map<string, GroupSocialState>`

`GroupSocialState`（P0 需要字段）：

- `groupId: string`
- `usageEvents: OutgoingUsageEvent[]`
- `pendingSends: Map<string, PendingSend>`
- `lastSpeakAt: number | null`
- `recentSkipCount: number`
- `dispatchState: GroupDispatchState`（调度闸门状态）
- `version: 1`

## 5.2 GroupDispatchState（调度闸门专用）

```ts
interface GroupDispatchState {
  /** 当前是否有批次正在 Agent 处理中 */
  dispatching: boolean;
  /** 等待队列中的消息（多次 flush/通知的消息自动合并到此） */
  pendingQueue: GroupMessage[];
  /** 上一次 Agent 处理完成的时间戳 */
  lastDispatchFinishedAt: number | null;
  /** 冷却定时器引用（用于取消） */
  cooldownTimer: ReturnType<typeof setTimeout> | null;
}
```

## 5.3 GroupMessageBuffer 扩展（建议）

- `pendingFlush: boolean`（dispatching 期间有新消息）
- `nextFlushAt: number | null`

---

## 6. 与现有代码的集成点

## 6.1 `src/group-client.ts`

- 修改 `bufferGroupMessage`：
  - 从立即 flush 改为短定时器二次聚合（轻量补充，服务端已做主要批量控制）。
  - flush 后不再直接调用 Agent，而是将消息列表交给调度闸门。
- 新增 `GroupDispatchQueue` 或在现有结构中增加调度逻辑：
  - 维护 `dispatching` / `pendingQueue` / `lastDispatchFinishedAt` 状态。
  - 提供 `enqueue(messages)` 方法供 flush 调用。
  - 内部管理串行派发与冷却定时器。

## 6.2 `src/monitor.ts`

在 `handleGroupMessagesForIdentity` 内拆分：

1. `enqueueToDispatchGate(...)`（新增，调度闸门入口）
2. `runGroupReplyDecision(...)`
3. `checkGroupBudget(...)`
4. `generateGroupReply(...)`
5. `scheduleAndSendGroupReply(...)`

## 6.3 `src/types.ts`

- 增加社交优化状态类型（含 `GroupDispatchState`）。
- 保持旧字段兼容，不移除既有类型。

## 6.4 `src/config-schema.ts`

新增 `session.groupSocial` 或 `groupSocial` 配置块（详见 `04-数据模型配置与兼容性设计.md`）。

---

## 7. 调度与决策伪代码

```ts
// ========== 调度闸门 ==========

class GroupDispatchQueue {
  private dispatching = false;
  private pendingQueue: GroupMessage[] = [];
  private lastDispatchFinishedAt: number | null = null;
  private cooldownTimer: ReturnType<typeof setTimeout> | null = null;

  constructor(
    private cooldownMs: number,  // 默认 30000
    private handler: (messages: GroupMessage[]) => Promise<void>,
  ) {}

  /** 缓冲闸门 flush 后调用此方法入队 */
  enqueue(messages: GroupMessage[]) {
    if (this.dispatching) {
      // Agent 正在处理中，消息进入等待队列
      this.pendingQueue.push(...messages);
      return;
    }

    if (this.cooldownTimer) {
      // 冷却期间，消息进入等待队列
      this.pendingQueue.push(...messages);
      return;
    }

    const now = Date.now();
    if (this.lastDispatchFinishedAt === null ||
        now - this.lastDispatchFinishedAt >= this.cooldownMs) {
      // 无需冷却，立即派发
      this.dispatch(messages);
    } else {
      // 需要等待剩余冷却时间
      this.pendingQueue.push(...messages);
      const remaining = this.cooldownMs - (now - this.lastDispatchFinishedAt);
      this.startCooldownTimer(remaining);
    }
  }

  private async dispatch(messages: GroupMessage[]) {
    this.dispatching = true;
    try {
      await this.handler(messages);
    } finally {
      this.dispatching = false;
      this.lastDispatchFinishedAt = Date.now();
      this.drainQueue();
    }
  }

  private drainQueue() {
    if (this.pendingQueue.length === 0) return;
    // 有等待中的消息，启动冷却定时器
    this.startCooldownTimer(this.cooldownMs);
  }

  private startCooldownTimer(delayMs: number) {
    if (this.cooldownTimer) clearTimeout(this.cooldownTimer);
    this.cooldownTimer = setTimeout(() => {
      this.cooldownTimer = null;
      if (this.pendingQueue.length === 0) return;
      // 取出全部等待消息，合并为一个批次派发
      const merged = this.pendingQueue.splice(0);
      this.dispatch(merged);
    }, delayMs);
  }
}

// ========== Agent 处理（意愿 + 预算 + 生成 + 延迟 + 发送） ==========

async function handleGroupBatch(state, groupId, messages) {
  if (!messages.length) return;

  const budgetPre = getBudgetStatus(state, groupId);
  if (budgetPre.exhausted) return;

  const decision = await runDecisionLLM({ state, groupId, messages, budgetPre });
  if (!decision.want_to_reply) return;

  const budgetBeforeGen = getBudgetStatus(state, groupId);
  if (budgetBeforeGen.exhausted) return;

  const reply = await runReplyLLM({ state, groupId, messages, decision });
  if (!reply.trim()) return;

  const delayMs = mapDelay(decision.delay_hint);
  schedule(async () => {
    const budgetBeforeSend = getBudgetStatus(state, groupId);
    if (budgetBeforeSend.exhausted) return;

    await sendGroupMessage(reply);
    recordUsage(state, groupId, reply);
  }, delayMs);
}

// ========== 组装 ==========

// 每个 (identityId, groupId) 创建一个 dispatchQueue
const queue = new GroupDispatchQueue(
  config.groupSocial.dispatch.cooldown_ms,  // 30000
  (messages) => handleGroupBatch(state, groupId, messages),
);

// 缓冲闸门 flush 时调用
queue.enqueue(flushedMessages);
```

---

## 8. 配置草案（P0）

```yaml
groupSocial:
  enabled: true

  batching:
    enabled: true
    interval_ms: 3000          # 客户端二次聚合间隔（轻量补充，服务端已做主要批量控制）

  dispatch:
    cooldown_ms: 30000         # 两次 Agent 处理之间的强制冷却间隔（默认 30s）

  decision:
    enabled: true
    default_skip_on_parse_error: true

  limits:
    short_window:
      duration_ms: 300000
      max_messages: 5
      max_tokens: 2000
    medium_window:
      duration_ms: 10800000
      max_messages: 30
      max_tokens: 30000
    long_window:
      duration_ms: 86400000
      max_messages: 100
      max_tokens: 100000

  delay:
    fast_ms: [2000, 6000]
    normal_ms: [8000, 20000]
    slow_ms: [20000, 60000]
```

---

## 9. 失败场景与降级策略

1. 决策 JSON 解析失败 -> 默认 skip。
2. 预算状态计算失败 -> 默认阻止发送（fail-closed）。
3. 延迟任务执行时 groupOps 不可用 -> 丢弃并记录日志。
4. 进程重启导致内存预算丢失 -> 从持久化文件恢复（若未恢复则按保守参数冷启动）。
5. 调度闸门 dispatch 异常（Agent 处理抛错） -> `finally` 中确保 `dispatching=false` 并记录 `lastDispatchFinishedAt`，不阻塞后续队列消费。
6. 冷却定时器被意外清除 -> 下一次 enqueue 时重新检查冷却条件，自愈。

---

## 10. 验收标准（P0）

必须满足：

1. `groupMessageIntervalMs` 可观测生效（日志可证明批处理）。
2. 出现消息洪峰时，skip 比例显著提高，且无持续秒回。
3. 配额触发后确实停止发送。
4. 发送数量在 5m/3h/24h 三窗口均受限。
5. 同一群同一身份同一时刻只有一个 Agent 处理在执行（串行化可观测）。
6. 两次 Agent 处理之间的间隔不小于配置的 `cooldown_ms`（日志可证明冷却生效）。
7. Agent 处理期间到达的多批消息被正确合并为一个批次处理（日志可证明合并）。
8. 不破坏现有 `acp_group` 工具链路与群管理功能。

---

## 11. 实施顺序（建议）

1. 先实现调度闸门（串行化 + 冷却间隔，立刻解决并发处理问题，最高优先级）。
2. 再改缓冲闸门（客户端二次聚合，轻量补充）。
3. 再加预算闸门（硬兜底）。
4. 再接决策闸门（减少无效生成）。
5. 最后接延迟闸门（降低同时回复）。

这样可以保证每一步都有独立收益并可回滚。

