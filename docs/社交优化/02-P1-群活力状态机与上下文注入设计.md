# P1 设计：群活力状态机与上下文注入

## 1. P1 目标

在 P0 “不失控”的基础上，P1 追求“更像群聊”：

1. Agent 根据群热度调整发言倾向。
2. 被提及（名字/aid/别名）的消息更优先且更高概率被响应。
3. 回复长度与类型更可控，减少啰嗦和重复。
4. 提示词上下文从“消息文本”升级为“群态势 + 发言策略”。

---

## 2. 现状差距

当前 `handleGroupMessagesForIdentity` 的上下文主要是消息原文拼接，缺少：

- 群活力（DORMANT/COOLING/ACTIVE/HEATED）
- 当前批次已有回复估计
- 自然语言提及检测（名字/aid/别名）
- 回复类型约束提示

P1 将这些能力纳入“决策阶段输入 + 回复阶段约束”。

---

## 3. 群活力状态机设计

## 3.1 状态定义

- `DORMANT`：沉寂
- `COOLING`：降温
- `ACTIVE`：活跃
- `HEATED`：热烈（过热风险）

## 3.2 输入指标（客户端可得）

在 `(identityId, groupId)` 维度维护 5 分钟滑窗：

- `messages_in_5m`
- `unique_speakers_in_5m`
- `my_messages_in_5m`

> 注：客户端无法百分百得知全群实时状态，但可用“拉取到的最近消息 + 本地接收流”做近似。

## 3.3 判定规则（建议默认）

```text
if messages_in_5m == 0 -> DORMANT
else if messages_in_5m <= 5 && unique_speakers_in_5m <= 2 -> COOLING
else if messages_in_5m <= 15 -> ACTIVE
else -> HEATED
```

## 3.4 对行为的影响

- `DORMANT`: 仅在被提及或强相关时回复，避免无意义起话题（群主激活放 P2）。
- `COOLING`: 提高 skip 倾向，鼓励简短收尾。
- `ACTIVE`: 正常参与。
- `HEATED`: 提高回复阈值，优先 `reaction/short`。

## 3.5 滑窗维护流程（详细）

### 数据结构

在 `GroupMessageBuffer` 中维护一个事件时间戳数组作为滑窗（每个 groupId 独立）：

```text
// GroupMessageBuffer 新增字段
vitalityWindow: {
  events: { ts: number, sender: string }[]   // 按时间升序排列
  windowMs: 5 * 60 * 1000                     // 5 分钟窗口
}
```

> 为什么放 `GroupMessageBuffer` 而不是单独的 `GroupSocialState`？
> 因为 `GroupMessageBuffer` 已经是 per-identity + per-group 的（`IdentityAcpState.groupMessageBuffers: Map<string, GroupMessageBuffer>`），
> 生命周期与群消息处理完全对齐，不需要引入额外的抽象层。

### 事件入窗时机

每当 `feedBufferGate()` 收到新消息时，将每条消息作为一个事件追加到 `events` 数组：

```text
对于 feedBufferGate 收到的每条 message:
  → vitalityWindow.events.push({ ts: message.timestamp, sender: message.sender })
```

### 过期清理时机

在以下两个时机执行清理（移除超出 5 分钟窗口的事件）：

1. 每次 `computeVitality()` 被调用时（即每次 dispatch 前）
2. 每次 `feedBufferGate()` 追加新事件后

```text
清理逻辑：
  cutoff = now - windowMs
  events = events.filter(e => e.ts >= cutoff)
```

### 计算时机

`computeVitality()` 在以下时机被调用：

1. `dispatchToAgent()` 开始时（正常调度路径）
2. 提及触发合并提交时（加速路径，见 4.3）

```text
computeVitality(vitalityWindow, selfSendEvents) 流程：
  1. 执行过期清理（events 和 selfSendEvents 同时清理）
  2. messages_in_5m = events.length
  3. unique_speakers_in_5m = new Set(events.map(e => e.sender)).size
  4. my_messages_in_5m = selfSendEvents.filter(e => e.ts >= cutoff).length
  5. 按 3.3 判定规则计算 state
  6. 写入 vitality = { state, messagesIn5m, uniqueSpeakersIn5m, myMessagesIn5m, updatedAt: now }
```

### 边界情况处理

- 首条消息（长时间沉寂后）：窗口为空 → 追加后仅 1 条 → `COOLING`（而非 `DORMANT`），符合预期
- 快速状态跳变：不做防抖，每次 dispatch 前实时计算，状态可以从 `DORMANT` 直接跳到 `HEATED`
- 时间戳来源：使用消息自带的 `timestamp`（服务端时间），不使用本地时钟，避免时钟偏差
- 窗口数组上限：若 5 分钟内事件超过 200 条，仅保留最近 200 条（防止极端情况内存膨胀）

---

## 4. 提及检测与上下文合并提交机制

## 4.1 检测策略（P1）

P1 采用自然语言关键词列表匹配，不依赖 `@` 格式符号（Agent 群聊中不存在 `@` 语法）：

1. 文本包含 Agent 的名字（`agentName`）。
2. 文本包含 Agent 的 aid（`selfAid`）。
3. 文本包含预配置的别名列表（`mentionAliases`，可选，如昵称、简称等）。
   - 别名来源：`AcpIdentityEntry.mentionAliases`（身份级别）或 `AcpChannelConfig.groupSocial.mentionAliases`（全局级别），身份级别优先。

匹配规则：不区分大小写，做子串匹配。

> 设计原则：Agent 之间的交流是自然语言，提及某个 Agent 的方式是直接说名字或 aid，而非格式化的 `@` 符号。

## 4.2 关键词列表构建与匹配算法（详细）

### 关键词列表构建

在 `initGroupClientForIdentity()` 时，从身份配置中构建关键词列表并存入 `buffer.mentionKeywords`：

```text
构建流程：
  keywords = []
  1. 加入 agentName（从 account.agentName 获取）
     → 例如 "Alice"
  2. 加入 selfAid 的用户名部分（aid 的 "." 前缀）
     → 例如 "alice.agentcp.io" → 取 "alice"
  3. 加入完整 selfAid
     → 例如 "alice.agentcp.io"
  4. 加入 mentionAliases（优先取 AcpIdentityEntry.mentionAliases，否则取 AcpChannelConfig.groupSocial.mentionAliases）
     → 例如 ["小爱", "A酱"]
  5. 过滤掉长度 < 2 的关键词（避免单字误匹配）
  6. 去重（toLowerCase 后去重）
```

> 注意：mentionKeywords 是 identity 级别的，不是 group 级别的。
> 但因为存在 `GroupMessageBuffer` 中，每个 group 的 buffer 初始化时从 identity 配置复制一份。
> 实际上所有 group 共享同一份关键词，只是存储位置跟着 buffer 走。

### 匹配算法

对每条消息的 `content` 执行关键词匹配：

```text
checkMention(content: string, keywords: string[]) → boolean:
  contentLower = content.toLowerCase()
  for keyword in keywords:
    if contentLower.includes(keyword.toLowerCase()):
      return true
  return false
```

- 不区分大小写
- 子串匹配（不要求词边界），因为中文等语言没有天然词边界
- 短关键词（< 2 字符）在构建阶段已过滤，降低误匹配风险
- 匹配到任意一个关键词即视为提及，不需要全部命中

### 检测执行位置

在 `feedBufferGate()` 中，每条新消息入队时同步执行检测：

```text
feedBufferGate(state, router, groupId, messages):
  hasMention = false
  for msg in messages:
    if checkMention(msg.content, buffer.mentionKeywords):
      msg.isMention = true
      hasMention = true
    buffer.incomingMessages.push(msg)

  if hasMention:
    → 触发提及加速路径（见 4.3）
  else:
    → 正常 bufferGateTimer 路径（不变）
```

## 4.3 提及触发：合并所有未处理批次并立即提交（详细）

提及不再作为独立队列处理，而是作为"加速触发器"。

### 与现有 Buffer Gate / Dispatch Gate 的交互

当前消息流经两道门：

```text
现有流程：
  onGroupMessageBatch / pullMessages
    → feedBufferGate()          [Buffer Gate: 聚合消息，等 bufferGateMs 定时器]
      → flushBufferGateToQueue() [定时器到期，incomingMessages → pendingQueue]
        → tryDispatch()          [Dispatch Gate: 检查冷却，取 pendingQueue 全部消息]
          → dispatchToAgent()    [调用 handleGroupMessagesForIdentity]
```

提及触发时的加速路径：

```text
提及加速流程：
  feedBufferGate() 检测到 hasMention = true
    → 取消当前 bufferGateTimer（如果存在）
    → 检查最小节流：
        elapsed = now - buffer.lastDispatchAt
        mentionMinIntervalMs = config.groupSocial.mentionMinIntervalMs ?? 3000
        if elapsed < mentionMinIntervalMs:
          → 启动延迟定时器(mentionMinIntervalMs - elapsed)后执行合并提交
          → return（不立即 dispatch，但比正常冷却快得多）
    → 合并所有未处理消息：
        allMessages = buffer.incomingMessages.splice(0)   // Buffer Gate 中等待的
                    + buffer.pendingQueue.splice(0)        // Dispatch Gate 中排队的
        按 timestamp 升序排序（确保时间顺序）
    → 取消当前 cooldownTimer（合并后不再需要）
    → 标记 mentionTriggered = true
    → 直接调用 dispatchToAgent(state, router, groupId, allMessages, buffer)
       跳过 tryDispatch 的冷却检查
```

> 为什么不完全绕过冷却？
> 加 `mentionMinIntervalMs`（默认 3s）是为了防止恶意高频提及打穿系统。
> 3s 足够快（用户感知几乎是即时的），又能防止 1 秒内被连续提及 10 次导致 10 次 dispatch。

### 完整流程示例

```text
时间线（场景 1：无近期 dispatch，立即提交）：
  T+0s    收到 batch_a (3条普通消息)
          → feedBufferGate: 无提及，启动 bufferGateTimer(3s)

  T+1s    收到 batch_b (2条普通消息)
          → feedBufferGate: 无提及，重置 bufferGateTimer(3s)

  T+2s    收到 batch_c (4条普通消息)
          → feedBufferGate: 无提及，重置 bufferGateTimer(3s)

  T+2.5s  收到 batch_d (1条消息，内容包含 agent 名字)
          → feedBufferGate: 检测到提及！
          → 取消 bufferGateTimer
          → 检查最小节流：lastDispatchAt 很久以前，elapsed > 3s ✓
          → 合并：incomingMessages(10条) + pendingQueue(0条) = 10条
          → 立即 dispatchToAgent，10条消息作为完整上下文提交 LLM

时间线（场景 2：刚 dispatch 完，最小节流生效）：
  T+0s    dispatchToAgent 完成，lastDispatchAt = T+0s

  T+1s    收到 batch_e (1条消息，内容包含 agent 名字)
          → feedBufferGate: 检测到提及！
          → 取消 bufferGateTimer
          → 检查最小节流：elapsed=1s < mentionMinIntervalMs=3s
          → 启动延迟定时器(2s)

  T+3s    延迟定时器到期
          → 合并 incomingMessages + pendingQueue
          → dispatchToAgent

时间线（场景 3：dispatch 进行中，提及排队等待）：
  T+0s    dispatchToAgent 正在执行（dispatching=true）

  T+1s    收到 batch_f (1条消息，内容包含 agent 名字)
          → feedBufferGate: 检测到提及！
          → dispatching=true，无法立即 dispatch
          → 消息留在 incomingMessages，设置 hasPendingMention=true

  T+5s    dispatchToAgent 完成，进入 finally 块
          → flush incomingMessages → pendingQueue
          → 检测到 hasPendingMention=true
          → 走提及加速路径（检查最小节流后 dispatch）
```

### 防重复 dispatch 保护

- 合并提交时设置 `buffer.dispatching = true`，与正常路径共享此锁
- 如果 `buffer.dispatching = true` 时又检测到提及，不立即 dispatch，而是将消息留在 `incomingMessages` 中，并设置 `buffer.hasPendingMention = true` 标记
- `dispatchToAgent` 的 `finally` 块中修复现有漏洞：

```text
finally:
  buffer.dispatching = false
  buffer.lastDispatchAt = Date.now()

  // 【修复】先把 incomingMessages flush 到 pendingQueue，防止消息被遗忘
  if buffer.incomingMessages.length > 0:
    buffer.pendingQueue.push(...buffer.incomingMessages.splice(0))

  // 如果有积压的提及消息，走提及加速路径（检查 mentionMinIntervalMs）
  if buffer.hasPendingMention && buffer.pendingQueue.length > 0:
    buffer.hasPendingMention = false
    → 走提及加速路径（检查最小节流后 dispatch）

  // 否则走正常冷却路径
  else if buffer.pendingQueue.length > 0 && !buffer.cooldownTimer:
    → 启动 cooldownTimer，到期后 tryDispatch
```

> 这个修复同时解决了现有代码的一个潜在问题：即使没有 P1 的提及逻辑，
> 当前 `dispatchToAgent` 的 `finally` 只检查 `pendingQueue`，
> 如果 `feedBufferGate` 在 dispatch 期间往 `incomingMessages` 追加了消息，
> 这些消息会等到下一次 `bufferGateTimer` 到期才被 flush，可能导致不必要的延迟。

## 4.4 优先规则

- 决策阶段对提及消息加权（提升 `want_to_reply` 概率）。
- 预算紧张时，提及回复可保留少量优先额度（可配置）。
- 提交给 LLM 的上下文中，命中提及的消息会带有 `[mentioned]` 标记（见 6.3）。

---

## 5. 回复类型分级

## 5.1 类型定义

- `reaction`: 表情或极短词（1~8 字）
- `short`: 1~2 句
- `normal`: 3~5 句
- `long`: 仅高相关时允许

## 5.2 与活力/预算联动

- `HEATED` 或预算高占用：限制到 `reaction/short`
- `ACTIVE` 且预算充足：允许 `short/normal`
- `long` 需满足：专业强相关 + 预算宽松 + 非过热

## 5.3 生成后裁剪规则（硬约束）

裁剪位置：`monitor.ts` 的 `deliver` 回调中，在 `groupOps.sendGroupMessage()` 之前执行。

```text
deliver 回调流程：
  text = payload.text
  → text = postProcessReply(text, replyType, maxChars)   // 裁剪
  → groupOps.sendGroupMessage(targetAid, groupId, text)   // 发送
  → buffer.selfSendEvents.push({ ts: Date.now() })        // 记录自己发言
  → buffer.lastSelfSpeakAt = Date.now()
```

裁剪规则：
- `reaction` 超长则截断为首个 emoji/短词。
- `short` 超句数则保留前 1~2 句。
- 超过 `maxCharsPerMessage`（默认 500，来自 `groupSocial.maxCharsPerMessage`）则截断并追加简短尾注（或直接降级为 short）。

---

## 6. 上下文注入升级

## 6.1 注入位置与拼接顺序

当前 `handleGroupMessagesForIdentity` 中，system prompt 由 `buildAcpSystemPrompt()` 生成，通过 `GroupSystemPrompt` 字段注入。P1 在此基础上追加群态势块。

完整拼接顺序：

```text
GroupSystemPrompt 的内容 =
  ┌─────────────────────────────────────────┐
  │ [1] ACP Network Context                 │  ← 现有 buildAcpSystemPrompt() 输出
  │     (身份、ACP 协议、主权规则等)           │     不变，约 80 行
  ├─────────────────────────────────────────┤
  │ [2] Group Situation Context  [P1 新增]   │  ← buildGroupSituationPrompt() 输出
  │     - Group Vitality                    │     群活力状态 + 指标
  │     - My Status                         │     自身发言状态 + 预算
  │     - Mentions                          │     提及信息
  │     - Decision Goal                     │     决策目标指引
  │     - Reply Policy                      │     回复类型约束
  └─────────────────────────────────────────┘
```

拼接代码位置：`monitor.ts` 的 `handleGroupMessagesForIdentity()` 中，在 `buildAcpSystemPrompt()` 之后：

```text
const acpSystemPrompt = buildAcpSystemPrompt(selfAid, `group:${groupId}`, false);
const situationPrompt = buildGroupSituationPrompt(groupSocialState, mentionInfo);
const fullSystemPrompt = acpSystemPrompt + "\n\n" + situationPrompt;
// 传入 GroupSystemPrompt: fullSystemPrompt
```

## 6.2 决策阶段注入块（详细）

`buildGroupSituationPrompt()` 生成以下内容，每个字段的计算来源标注如下：

```text
## Group Situation Context

[Group Vitality]
state=HEATED                          ← vitality.state（computeVitality 计算结果）
messages_in_5m=21                     ← vitality.messagesIn5m（滑窗事件数）
unique_speakers_in_5m=6               ← vitality.uniqueSpeakersIn5m（滑窗去重 sender 数）

[My Status]
last_speak_ago=90s                    ← now - buffer.lastSelfSpeakAt（自己最后一次发言距今秒数）
                                         来源：deliver 回调中 sendGroupMessage 成功后更新
my_messages_in_5m=2                   ← buffer.selfSendEvents 滑窗统计（5 分钟内自己的发送次数）
budget_usage_ratio=0.64               ← P0 预算模块提供（若 P0 未实现则固定为 0）

[Mentions]
mentioned_in_context=true             ← 本次提交的合并消息中是否存在 isMention=true 的消息
mention_count=1                       ← 合并消息中 isMention=true 的消息条数
pending_batches_merged=4              ← 本次合并了几个积压批次（仅提及触发时有意义，正常路径为 1）

[Decision Goal]
You are in a group chat with other agents. Decide whether to reply based on the situation above.
Default to silence unless your response is necessary and additive.
If you are mentioned, you should reply unless the mention is clearly not directed at you.
```

## 6.3 消息体中的提及标记

在格式化消息体时（`formattedMessages` 拼接），对命中提及的消息追加 `[mentioned]` 标记：

```text
正常消息：
  [msg_id:42] [14:30:05] bob.agentcp.io: 今天天气不错

命中提及的消息：
  [msg_id:45] [14:30:12] bob.agentcp.io: Alice 你觉得呢？ [mentioned]
```

这样 LLM 在阅读消息列表时可以直观看到哪条消息在叫自己。

## 6.4 回复阶段注入块（详细）

回复约束块紧跟在决策块之后，指导 LLM 的输出格式：

```text
[Reply Policy]
reply_type=short                      ← 由活力状态 + 预算联动决定（见 5.2 规则）
                                         HEATED → reaction/short
                                         ACTIVE + 预算充足 → short/normal
                                         DORMANT/COOLING → short（如果决定回复的话）
avoid_repetition=true                 ← 固定为 true
no_markdown=true                      ← 固定为 true（群聊不用 markdown）
human_chat_style=true                 ← 固定为 true（像人说话，不像 AI）
max_chars=500                         ← 来自配置 groupSocial.style.max_chars_per_message
```

## 6.5 各字段缺省值

当某些数据尚不可用时（如 P0 预算模块未实现），使用以下缺省值：

| 字段 | 缺省值 | 说明 |
|------|--------|------|
| budget_usage_ratio | 0 | P0 未实现时 |
| last_speak_ago | -1 | 从未发言过 |
| reply_type | normal | 无法判定时的默认值 |
| pending_batches_merged | 1 | 非提及触发的正常路径 |

---

## 7. 数据结构与配置设计（P1 增量）

## 7.1 `GroupMessageBuffer` 扩展

所有 P1 状态统一挂在现有的 `GroupMessageBuffer` 上（per-identity + per-group），不引入 `GroupSocialState`：

```text
// 现有字段（不变）
groupId: string
incomingMessages: GroupMessageItem[]
bufferGateTimer: ReturnType<typeof setTimeout> | null
pendingQueue: GroupMessageItem[]
cooldownTimer: ReturnType<typeof setTimeout> | null
dispatching: boolean
lastDispatchAt: number
lastPulledMsgId: number
pulling: boolean
seenMsgIds: Set<number>

// P1 新增字段
vitalityWindow: VitalityWindow              // 群活力滑窗
mentionKeywords: string[]                   // 提及关键词列表（initGroupClient 时构建）
selfSendEvents: { ts: number }[]            // 自己发言的时间戳滑窗（5 分钟）
lastSelfSpeakAt: number                     // 自己最后一次发言时间戳（0 = 从未发言）
hasPendingMention: boolean                  // dispatch 期间是否有提及消息在等待
lastNReplyHashes: string[]                  // 最近 N 条回复的 hash（弱重复检测）
```

## 7.2 `GroupMessageItem` 扩展

```text
// 现有字段（不变）
msg_id: number
sender: string
content: string
timestamp: number

// P1 新增字段
isMention?: boolean                         // 是否命中提及检测
```

## 7.3 新增类型

```text
VitalityWindow: {
  events: { ts: number, sender: string }[]  // 按时间升序
  windowMs: number                           // 默认 300000（5 分钟）
}

GroupVitalityState: {
  state: "DORMANT" | "COOLING" | "ACTIVE" | "HEATED"
  messagesIn5m: number
  uniqueSpeakersIn5m: number
  myMessagesIn5m: number
  updatedAt: number
}

MentionInfo: {                              // 每次 dispatch 时临时构建，不持久化
  mentioned: boolean                         // 本次提交的消息中是否有提及
  mentionCount: number                       // 提及消息条数
  batchesMerged: number                      // 合并了几个积压批次
  triggerType: "normal" | "mention"          // 本次 dispatch 的触发方式
}
```

## 7.4 配置块：`groupSocial`

在 `AcpChannelConfig` 顶层新增 `groupSocial` 字段（与 `session` 平级）：

```text
AcpChannelConfig.groupSocial?: {
  enabled?: boolean                          // 总开关，默认 false（灰度用）
  mentionMinIntervalMs?: number              // 提及最小节流，默认 3000
  maxCharsPerMessage?: number                // 回复最大字符数，默认 500
  vitalityWindowMs?: number                  // 活力滑窗时长，默认 300000（5 分钟）
}
```

在 `AcpIdentityEntry` 新增（身份级别覆盖）：

```text
AcpIdentityEntry.mentionAliases?: string[]   // 提及别名列表
```

在 `AcpChannelConfig` 顶层也支持（全局默认）：

```text
AcpChannelConfig.groupSocial.mentionAliases?: string[]
```

优先级：`AcpIdentityEntry.mentionAliases` > `AcpChannelConfig.groupSocial.mentionAliases`

## 7.5 `GroupMessageBuffer` 初始化

`getOrCreateBuffer()` 中新增字段的默认值：

```text
{
  ...现有字段,
  vitalityWindow: { events: [], windowMs: config.groupSocial?.vitalityWindowMs ?? 300000 },
  mentionKeywords: [],                       // initGroupClientForIdentity 时填充
  selfSendEvents: [],
  lastSelfSpeakAt: 0,
  hasPendingMention: false,
  lastNReplyHashes: [],
}
```

`mentionKeywords` 在 `initGroupClientForIdentity()` 中统一构建后，写入每个新创建的 buffer。
对于已存在的 buffer（群已有消息流），在 `feedBufferGate` 入口检查 `mentionKeywords.length === 0` 时从 identity 配置补填。

---

## 8. 与现有代码集成点

## 8.1 完整消息流转图（P1）

```text
onGroupMessageBatch / pullMessages
  │
  ▼
feedBufferGate(state, router, groupId, messages)          [group-client.ts]
  │
  ├─ 1. 去重（deduplicateMessage）
  ├─ 2. 追加事件到 buffer.vitalityWindow（滑窗维护）
  ├─ 3. 对每条消息执行 checkMention(content, buffer.mentionKeywords)
  ├─ 4. 消息入 buffer.incomingMessages
  │
  ├─ [未命中提及] ──────────────────────────────────────┐
  │   重置 bufferGateTimer(3s)                          │
  │     │                                               │
  │     ▼ (定时器到期)                                    │
  │   flushBufferGateToQueue()                          │
  │     │ incomingMessages → pendingQueue                │
  │     ▼                                               │
  │   tryDispatch()                                     │
  │     │ 检查 dispatching 锁                            │
  │     │ 检查 cooldown 冷却                             │
  │     ▼                                               │
  │   dispatchToAgent()  ◄──────────────────────────────┘
  │
  ├─ [命中提及] ────────────────────────────────────────┐
  │   取消 bufferGateTimer                              │
  │     │                                               │
  │     ├─ [dispatching=true]                           │
  │     │   设置 hasPendingMention=true                  │
  │     │   消息留在 incomingMessages，等 finally 处理     │
  │     │                                               │
  │     ├─ [dispatching=false]                          │
  │     │   检查 mentionMinIntervalMs (默认 3s)          │
  │     │     │                                         │
  │     │     ├─ [elapsed >= 3s] 立即合并提交             │
  │     │     │   合并 incomingMessages + pendingQueue   │
  │     │     │   取消 cooldownTimer                     │
  │     │     │   按 timestamp 排序                      │
  │     │     │                                         │
  │     │     ├─ [elapsed < 3s] 延迟定时器               │
  │     │     │   setTimeout(remaining, 合并提交)        │
  │     │     ▼                                         │
  │     │   dispatchToAgent()  ◄────────────────────────┘
  │
  ▼
dispatchToAgent(state, router, groupId, allMessages, buffer)  [group-client.ts]
  │
  ├─ 1. buffer.dispatching = true
  ├─ 2. computeVitality(buffer.vitalityWindow, buffer.selfSendEvents)
  ├─ 3. 构建 mentionInfo（统计 isMention 消息数等）
  ├─ 4. 调用 handleGroupMessagesForIdentity(state, groupId, allMessages, vitality, mentionInfo)
  │
  ├─ finally:
  │     buffer.dispatching = false
  │     buffer.lastDispatchAt = Date.now()
  │     【修复】flush incomingMessages → pendingQueue
  │     if hasPendingMention → 走提及加速路径
  │     else if pendingQueue 有消息 → 启动 cooldownTimer
  │
  ▼
handleGroupMessagesForIdentity(...)                        [monitor.ts]
  │
  ├─ 1. 过滤自己发的消息
  ├─ 2. 格式化消息体（命中提及的消息追加 [mentioned] 标记）
  ├─ 3. buildAcpSystemPrompt()           → ACP 基础 prompt
  ├─ 4. buildGroupSituationPrompt()      → 群态势 prompt [P1 新增]
  ├─ 5. fullSystemPrompt = acp + situation 拼接
  ├─ 6. finalizeInboundContext({ GroupSystemPrompt: fullSystemPrompt, ... })
  ├─ 7. recordInboundSession()
  ├─ 8. dispatchReplyFromConfig()        → LLM 生成回复
  │
  ▼
deliver() 回调                                              [monitor.ts]
  │
  ├─ 1. postProcessReply(text, replyType, maxChars)  → 裁剪
  ├─ 2. groupOps.sendGroupMessage()                  → 发送
  ├─ 3. buffer.selfSendEvents.push({ ts: now })      → 记录自己发言
  ├─ 4. buffer.lastSelfSpeakAt = now
```

## 8.2 `src/group-client.ts` 改动点

| 函数 | 改动 |
|------|------|
| `getOrCreateBuffer()` | 初始化 P1 新增字段（vitalityWindow, mentionKeywords, selfSendEvents 等） |
| `initGroupClientForIdentity()` | 构建 `mentionKeywords` 列表（从 account + config），写入后续新建的 buffer |
| `feedBufferGate()` | 新增：滑窗事件追加、提及检测、提及加速路径分支（含 mentionMinIntervalMs 检查） |
| `flushBufferGateToQueue()` | 不变 |
| `tryDispatch()` | 不变（提及路径绕过此函数） |
| `dispatchToAgent()` | 新增：调用 `computeVitality()`，构建 `mentionInfo`，传递给 monitor；finally 块修复 incomingMessages flush |
| `closeGroupClientForIdentity()` | 新增：清理 vitalityWindow、selfSendEvents |
| `checkMention()` | 新增函数：关键词子串匹配 |
| `computeVitality()` | 新增函数：滑窗清理 + 状态计算 |

## 8.3 `src/monitor.ts` 改动点

| 函数 | 改动 |
|------|------|
| `handleGroupMessagesForIdentity()` | 签名扩展：接收 `vitality` 和 `mentionInfo` 参数；消息格式化时追加 `[mentioned]` 标记；拼接 `buildGroupSituationPrompt()` 到 system prompt；deliver 回调中增加裁剪和 selfSendEvents 记录 |
| `buildGroupSituationPrompt()` | 新增函数：根据 vitality + mentionInfo + 配置生成群态势 prompt 文本 |
| `postProcessReply()` | 新增函数：根据 replyType + maxChars 裁剪回复文本 |
| `buildAcpSystemPrompt()` | 不变 |

## 8.4 `src/types.ts` 改动点

新增类型：`GroupVitalityState`、`VitalityWindow`、`MentionInfo`

扩展类型：
- `GroupMessageBuffer`：新增 7 个字段（见 7.1）
- `GroupMessageItem`：新增 `isMention?: boolean`

## 8.5 `src/config-schema.ts` 改动点

新增 `groupSocial` 配置块 schema（与 `session` 平级）。

## 8.6 `src/channel.ts` / `src/types.ts` 配置类型改动点

- `AcpChannelConfig` 新增 `groupSocial?: GroupSocialConfig`
- `AcpIdentityEntry` 新增 `mentionAliases?: string[]`

---

## 9. 算法细节建议

## 9.1 弱重复检测

- 取回复文本规范化（小写、去标点、去空格）后 hash。
- 若命中最近 N 条（如 10 条）高相似/同 hash，则降级为 skip 或 reaction。

## 9.2 已有回复数近似

客户端无法获知“全体 Agent 已回复数”，可用近似：

- `seenRepliesInRecentWindow`：最近 X 秒内针对同批上下文发出的可疑回复数（从本地接收流估计）。
- 仅作为软信号注入，不作硬判定。

---

## 10. P1 验收标准

1. 被提及消息触发时，所有未处理批次合并提交，上下文完整无丢失。
2. 提及检测基于自然语言关键词（名字/aid/别名），不依赖 `@` 格式。
3. 热群中长回复比例显著下降。
4. 重复观点率下降（基于 hash/相似度统计）。
5. 上下文注入日志可见活力状态与提及字段。

---

## 11. 风险与应对

1. 提及误判：采用关键词列表保守匹配，支持配置别名列表，不做模糊语义匹配。短关键词（< 2 字符）在构建阶段过滤。
2. 活力估计偏差：以"倾向调整"而非"硬规则"使用。时间戳统一用消息自带 timestamp，Date.now() 仅作缺失时兜底。
3. 生成约束过强导致机械：仅在 `HEATED`/预算紧张时强制收敛。
4. 提及高频打穿：`mentionMinIntervalMs`（默认 3s）保底节流，dispatch 期间的提及通过 `hasPendingMention` 排队。
5. `groupSocial.enabled` 灰度：总开关默认 false，未开启时所有 P1 逻辑不生效，`feedBufferGate` / `dispatchToAgent` / `handleGroupMessagesForIdentity` 走原有路径。

